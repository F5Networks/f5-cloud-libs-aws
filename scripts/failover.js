#!/usr/bin/env node

/**
 * Copyright 2018 F5 Networks, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

'use strict';

const parser = require('commander');
const fs = require('fs');
const q = require('q');
const AWS = require('aws-sdk');
const f5CloudLibs = require('@f5devcentral/f5-cloud-libs');

const util = f5CloudLibs.util;
const Logger = f5CloudLibs.logger;

// Parse command line arguments
parser
    .version('1.0.0')
    .option('--log-level [type]', 'Specify the log level', 'info')
    .option('--log-file [type]', 'Specify the log file location', '/var/log/cloud/aws/failover.log')
    .option('--tag-key [type]', 'Specify the key for the tag', 'f5_deployment')
    .option('--tag-value [type]', 'Specify the value of the tag', '')
    .option('--vip-allocation-id [type]', 'Specify the Allocation ID of the Virtual IP address', '')
    .option('--private-ip [type]', 'Specify the Private IP address to associate with', '')
    .option('--associate-eni [type]', 'Specify the ENI of the network interface to associate with', '')
    .option('--password-uri [type]', 'Specify URI password of the BIG-IQ', '')
    .parse(process.argv);
const loggerOptions = { logLevel: parser.logLevel, fileName: parser.logFile, console: true };
const logger = Logger.getLogger(loggerOptions);
const BigIp = f5CloudLibs.bigIp;
const bigip = new BigIp({ logger });

// Initialize global vars
const IID_FILE_PATH = '/shared/vadc/aws/iid-document';
const primaryState = 'PRIMARY';
const secondaryState = 'SECONDARY';
const tagKey = parser.tagKey;
const tagValue = parser.tagValue;
const allocationEipId = parser.vipAllocationId;
const privateIpAddressToAssociate = parser.privateIp;
const passwordUri = parser.passwordUri;
const networkInterfaceIdIdToAssociate = parser.associateEni;
let associationIdToDisassociate;
let allocationIdToAssociate;

let ec2;
let curIidData;
let associateRequired = false;
let bigIqPasswordData = {};

/**
 * Determine PRIMARY state
 *
 * @return {Promise} A promise which is resolved upon PRIMARY state of the current instance is determined
 */
function getFailoverStatus() {
    const deferred = q.defer();
    util.readData(passwordUri, true)
        .then((uriData) => {
            bigIqPasswordData = util.lowerCaseKeys(
                JSON.parse(uriData.trim())
            );
            return bigip.init(
                'localhost',
                'admin',
                bigIqPasswordData.admin,
                {
                    port: '443'
                }
            );
        })
        .then(() => {
            return bigip.list('/shared/failover-state');
        })
        .then((results) => {
            if (results !== undefined) {
                const failoverStatus = results.nodeRole;
                deferred.resolve(failoverStatus);
            } else {
                logger.error('Fail to retrieve failover-status');
                deferred.reject(results);
            }
        })
        .catch((err) => {
            logger.info(`Error getting failover state: ${err}`);
            deferred.reject(err);
        });
    return deferred.promise;
}

/**
 * Config AWS
 *
 * @return {Promise} A promise which is resolved upon AWS configuration completion
 */
function configureAWS() {
    const deferred = q.defer();
    AWS.config.getCredentials((err) => {
        if (err) {
            deferred.reject(err);
        } else {
            const creds = {
                accessKey: AWS.config.credentials.accessKeyId,
                secretKey: AWS.config.credentials.secretAccessKey
            };
            deferred.resolve(creds);
        }
    });
    return deferred.promise;
}

/**
 * Get data from iid doc (generated by AWS)
 *
 * @return A promise which is resolved upon data is read from iid doc
 */
function getIidDoc() {
    const deferred = q.defer();
    fs.readFile(IID_FILE_PATH, (err, data) => {
        if (err) {
            logger.error(`Error reading IID file: ${err}`);
            deferred.reject(err);
        } else {
            deferred.resolve(JSON.parse(data.toString()));
        }
    });
    return deferred.promise;
}

/**
 * Get tag information of an Elastic IP
 *
 * @returns {Promise} A promise which is resolved upon tag information is retrieved
 */
function getTagInfo() {
    const deferred = q.defer();
    const params = {
        Filters: [
            {
                Name: 'key',
                Values: [tagKey]
            },
            {
                Name: 'value',
                Values: [tagValue]
            },
            {
                Name: 'resource-type',
                Values: ['elastic-ip']
            }
        ]
    };
    ec2.describeTags(params, (err, data) => {
        if (err) {
            logger.error(`Error describe tag: ${err}`);
            deferred.reject(err);
        } else {
            deferred.resolve(data);
        }
    });
    return deferred.promise;
}

/**
 * Tag an Elastic IP address if needed
 *
 * @param {Object} tagData - retrieved tag information
 *
 * @return {Promise} A promise which is resolved upon matching tag is retrieved or added
 *
 */
function addTag(tagData) {
    const deferred = q.defer();
    const numTags = Object.keys(tagData.Tags).length;
    if (numTags === 0) {
        logger.info(`Tag ${tagKey} not found. Creating tag on resource ${allocationEipId}`);
        const createTagParams = {
            Resources: [
                allocationEipId
            ],
            Tags: [
                {
                    Key: tagKey,
                    Value: tagValue
                }
            ]
        };

        ec2.createTags(createTagParams, (err, data) => {
            if (err) {
                logger.error(`Error adding tag: ${err}`);
                deferred.reject(err);
            } else {
                deferred.resolve(data);
            }
        });
    } else if (numTags === 1) {
        logger.info('Tag found, no need add tag');
        deferred.resolve(tagData);
    } else {
        const errorMessage = `Error: multiple tags: ${tagData.Tags}`;
        logger.error(errorMessage);
        deferred.reject(errorMessage);
    }
    return deferred.promise;
}

/**
 *  Get  network addresses
 */
function getNetworkAddresses(curInstanceId) {
    const deferred = q.defer();
    const describeAddressesParams = {
        Filters: [
            {
                Name: 'domain',
                Values: ['vpc']
            },
            {
                Name: `tag:${tagKey}`,
                Values: [tagValue]
            }
        ]
    };

    ec2.describeAddresses(describeAddressesParams, (err, data) => {
        if (err) {
            logger.error(`Error getting network addresses: ${err.stack}`);
            deferred.reject(err);
        } else {
            const matchedAddress = data.Addresses;
            if (Array.isArray(matchedAddress) && (matchedAddress.length === 1)) {
                if (curInstanceId !== matchedAddress[0].InstanceId) {
                    associationIdToDisassociate = matchedAddress[0].AssociationId;
                    allocationIdToAssociate = matchedAddress[0].AllocationId;
                    associateRequired = true;
                }
            }
            deferred.resolve();
        }
    });
    return deferred.promise;
}

/**
 * Disassociate an IP address
 */
function disassociateIpAddress() {
    const deferred = q.defer();
    if (associateRequired) {
        logger.info('Disassociate Virtual IP address');
        const params = {
            AssociationId: associationIdToDisassociate
        };
        ec2.disassociateAddress(params, (err, data) => {
            if (err) {
                logger.error(`Fail to disassociate IP address: ${err}`);
                deferred.reject(err);
            } else {
                deferred.resolve(data);
            }
        });
    } else {
        logger.info(`${primaryState} device already has virtual IP address. ` +
        'Disassociation is not required.');
        deferred.resolve();
    }
    return deferred.promise;
}

/**
 * Associate an IP address
 */
function associateIpAddress() {
    const deferred = q.defer();
    if (associateRequired) {
        logger.info('Associate Virtual IP address.');
        const params = {
            AllocationId: allocationIdToAssociate,
            NetworkInterfaceId: networkInterfaceIdIdToAssociate,
            PrivateIpAddress: privateIpAddressToAssociate
        };
        ec2.associateAddress(params, (err, data) => {
            if (err) {
                logger.error(`Fail to associate IP address: ${err}.`);
                deferred.reject(err);
            } else {
                deferred.resolve(data);
            }
        });
    } else {
        logger.info(`${primaryState} device already has virtual IP address. Association is not required.`);
        deferred.resolve();
    }
    return deferred.promise;
}

/**
 * Initialize resources
 *
 * @param {String} reg - Region to deploy Azure ARM
 *
 * @return {Promise} A promise which is resolved upon initialization completion
 *
 */
function init() {
    const deferred = q.defer();
    Promise.all([
        getIidDoc(),
        configureAWS()
    ])
        .then((data) => {
            curIidData = data[0];
            AWS.config.update({ region: curIidData.region });
            ec2 = new AWS.EC2({ apiVersion: '2016-11-15' });
            deferred.resolve();
        })
        .catch((err) => {
            logger.error(`Failed to initialize AWS configuration: ${err}`);
            deferred.reject();
        });
    return deferred.promise;
}

/**
  * Perform failover
  *
  */
function failover() {
    init()
        .then(() => {
            return getTagInfo();
        })
        .then((tagData) => {
            logger.info('Create tag If neccessary');
            return addTag(tagData);
        })
        .then(() => {
            return getNetworkAddresses(curIidData.instanceId);
        })
        .then(() => {
            return disassociateIpAddress();
        })
        .then(() => {
            return associateIpAddress();
        })
        .catch((error) => {
            logger.info(`Failover failed: ${error}`);
        });
}

/**
 * Main processing
 */
function main() {
    getFailoverStatus()
        .then((status) => {
            if (status === primaryState) {
                return failover();
            }
            logger.info(`No need to perform failover for ${secondaryState} device`);
            return q();
        })
        .catch((error) => {
            logger.error(`Failover failed: ${error}`);
        });
}

main();
